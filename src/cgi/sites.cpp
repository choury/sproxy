#include "res/cgi.h"
#include "prot/rpc.h"
#include "misc/util.h"
#include "misc/config.h"
#include "misc/strategy.h"

#include <string.h>
#include <json.h>

class handler: public CgiHandler{
    static SproxyClient* c;

    void generatePacResponse(const std::vector<std::string>& slist) {
        std::shared_ptr<HttpResHeader> res = HttpResHeader::create(S200, sizeof(S200), req->request_id);
        res->set("Content-Type", "application/x-ns-proxy-autoconfig");
        res->set("Cache-Control", "no-cache");
        Response(res);

        std::string pac_content =
            "function FindProxyForURL(url, host) {\n"
            "    // Convert host to lowercase for case-insensitive matching\n"
            "    var lhost = host.toLowerCase();\n"
            "    \n";

        // Get proxy server address from request destination
        std::string default_proxy;
        if(req->Dest.scheme[0] && strcasecmp(req->Dest.scheme, "https") == 0) {
            default_proxy = "HTTPS " + std::string(dumpAuthority(&req->Dest));
        } else {
            default_proxy = "PROXY " + std::string(dumpAuthority(&req->Dest));
        }

        // Add PAC file header with comments
        pac_content += "    // Generated by sproxy - Proxy Auto-Configuration\n";
        pac_content += "    // " + default_proxy + " = Use sproxy for this request\n";
        pac_content += "    // DIRECT = Connect directly without proxy\n";
        pac_content += "    // Block = Reject connection (invalid proxy)\n";
        pac_content += "    // For 'block' strategy: ext field = path regex pattern\n";
        pac_content += "    // For 'proxy' strategy: ext field = custom proxy server\n";
        pac_content += "    \n";

        // Parse strategy list and generate PAC rules
        for(const auto& item: slist) {
            char site[DOMAINLIMIT];
            char strategy[20];
            char ext[256];
            int parsed = sscanf(item.c_str(), "%s %s %s", site, strategy, ext);

            // Skip malformed entries (need at least site and strategy)
            if(parsed < 2) {
                continue;
            }

            std::string site_str(site);
            std::string strategy_str(strategy);
            std::string ext_str = (parsed >= 3) ? ext : "";

            if(ext_str == GEN_TIP) {
                continue;
            }

            // Skip direct strategy as it's the default
            if(strategy_str == "direct") {
                continue;
            }

            // Build condition based on host pattern and optional path (for block strategy)
            std::string condition;
            // Generate host matching condition
            if(site_str.find("*") != std::string::npos) {
                // Wildcard domain pattern
                std::string pattern = site_str;
                size_t pos = pattern.find("*.");
                if(pos == 0) {
                    pattern = pattern.substr(2); // Remove "*."
                    condition = "(dnsDomainIs(lhost, \"." + pattern + "\") || lhost == \"" + pattern + "\")";
                } else {
                    // Other wildcard patterns - convert to simple substring match
                    condition = "shExpMatch(lhost, \"" + site_str + "\")";
                }
            } else if(site_str.find("/") != std::string::npos) {
                // IP/CIDR pattern - handle both IPv4 and IPv6
                size_t slash_pos = site_str.find("/");
                std::string ip = site_str.substr(0, slash_pos);
                std::string mask_bits = site_str.substr(slash_pos + 1);

                // Check if it's IPv6 (contains colons or brackets)
                if(ip.find(":") != std::string::npos) {
                    // IPv6 - PAC doesn't have good IPv6 support, use simple string matching
                    // Remove brackets if present for comparison
                    std::string clean_ip = ip;
                    if(clean_ip[0] == '[' && clean_ip.back() == ']') {
                        clean_ip = clean_ip.substr(1, clean_ip.length() - 2);
                    }
                    condition = "host.indexOf(\"" + clean_ip + "\") === 0";
                } else {
                    // IPv4 - use isInNet function
                    // Convert CIDR to netmask (simplified for common cases)
                    std::string netmask = "255.255.255.0"; // Default /24
                    if(mask_bits == "8") netmask = "255.0.0.0";
                    else if(mask_bits == "16") netmask = "255.255.0.0";
                    else if(mask_bits == "24") netmask = "255.255.255.0";

                    condition = "isInNet(host, \"" + ip + "\", \"" + netmask + "\")";
                }
            } else {
                // Exact match - check if it's IPv6 or domain name
                if(site_str.find(":") != std::string::npos) {
                    // IPv6 address - handle with or without brackets
                    std::string clean_ip = site_str;
                    if(clean_ip[0] == '[' && clean_ip.back() == ']') {
                        clean_ip = clean_ip.substr(1, clean_ip.length() - 2);
                    }
                    condition = "host == \"" + site_str + "\" || host == \"[" + clean_ip + "]\"";
                } else {
                    // Domain name or IPv4
                    condition = "lhost == \"" + site_str + "\"";
                }
            }

            // Add path condition if present (only for block strategy, supports regex)
            if(strategy_str == "block" && !ext_str.empty() && ext_str[0] == '/') {
                // Escape special characters for JavaScript regex literal
                std::string regex_pattern = ext_str;
                size_t pos = 0;

                // Escape backslashes first (must be done before escaping other chars)
                while((pos = regex_pattern.find("\\", pos)) != std::string::npos) {
                    regex_pattern.replace(pos, 1, "\\\\");
                    pos += 2;
                }

                // Escape forward slashes (for regex literal)
                pos = 0;
                while((pos = regex_pattern.find("/", pos)) != std::string::npos) {
                    regex_pattern.replace(pos, 1, "\\/");
                    pos += 2;
                }

                // Escape quotes for JavaScript string
                pos = 0;
                while((pos = regex_pattern.find("\"", pos)) != std::string::npos) {
                    regex_pattern.replace(pos, 1, "\\\"");
                    pos += 2;
                }

                condition += " && /" + regex_pattern + "/.test(url)";
            }
            pac_content += "    if (" + condition + ") {\n";

            // Add action based on strategy
            if(strategy_str == "proxy") {
                if(!ext_str.empty() && ext_str.find("://") != std::string::npos) {
                    // Custom proxy server specified in ext field, parse it properly
                    Destination custom_dest;
                    if(parseDest(ext_str.c_str(), &custom_dest) == 0) {
                        std::string custom_proxy;
                        if(custom_dest.scheme[0] && strcasecmp(custom_dest.scheme, "https") == 0) {
                            custom_proxy = "HTTPS " + std::string(dumpAuthority(&custom_dest));
                        } else {
                            custom_proxy = "PROXY " + std::string(dumpAuthority(&custom_dest));
                        }
                        pac_content += "        return \"" + custom_proxy + "\"; // Custom proxy\n";
                    } else {
                        // Parse failed, use default proxy
                        pac_content += "        return \"" + default_proxy + "\"; // Parse failed, use default\n";
                    }
                } else {
                    pac_content += "        return \"" + default_proxy + "\"; // Use sproxy\n";
                }
            } else if(strategy_str == "block") {
                pac_content += "        return \"PROXY 240.0.0.1:1\"; // Block access\n";
            } else if(strategy_str == "forward" || strategy_str == "rewrite") {
                pac_content += "        return \"" + default_proxy + "\"; // Forward via sproxy\n";
            } else if(strategy_str == "local") {
                pac_content += "        return \"DIRECT\"; // Local access\n";
            } else {
                // For unknown strategies, use direct connection
                pac_content += "        return \"DIRECT\"; // Unknown strategy - direct\n";
            }
            pac_content += "    }\n";
        }

        pac_content +=
            "    \n"
            "    // Default: direct connection\n"
            "    return \"DIRECT\";\n"
            "}\n";

        Send(pac_content.c_str(), pac_content.length());
        Finish();
    }
    void GET(const CGI_Header*) override{
        if(strcmp(req->get("X-Authorized"), "1") != 0) {
            Response(HttpResHeader::create(S403, sizeof(S403), req->request_id));
            Finish();
            return;
        }
        if((flag & HTTP_REQ_COMPLETED) == 0){
            return;
        }
        auto slist = c->DumpStrategy().get_future().get();

        // Check if PAC format is requested
        auto it = params.find("format");
        if(it != params.end() && it->second == "pac") {
            generatePacResponse(slist);
            return;
        }

        json_object* jsites = json_object_new_array();
        for(const auto& item: slist) {
            char site[DOMAINLIMIT];
            char strategy[20];
            sscanf(item.c_str(), "%s %s", site, strategy);
            json_object *jsite = json_object_new_object();
            json_object_object_add(jsite, site, json_object_new_string(strategy));
            json_object_array_add(jsites, jsite);
        }
        std::shared_ptr<HttpResHeader> res = HttpResHeader::create(S200, sizeof(S200), req->request_id);
        res->set("Content-Type", "application/json");
        Cookie cookie;
        cookie.path = "/";
        cookie.domain = req->Dest.hostname;
        cookie.maxage = 3600;
        for(const auto& i: params){
            cookie.set(i.first.c_str(), i.second.c_str());
            res->addcookie(cookie);
        }
        Response(res);
        const char* jstring = json_object_get_string(jsites);
        Send(jstring, strlen(jstring));
        json_object_put(jsites);
        Finish();
    }
    void POST(const CGI_Header* header) override {
        if(strcmp(req->get("X-Authorized"), "1") != 0) {
            Response(HttpResHeader::create(S403, sizeof(S403), req->request_id));
            Finish();
            return;
        }
        if(header->type == CGI_DATA){
            auto param = getparamsmap((char *)(header+1), ntohs(header->contentLength));
            params.insert(param.begin(), param.end());
        }
        if((flag & HTTP_REQ_COMPLETED) == 0){
            return;
        }
        if(params["method"] == "delete"){
            return DELETE(header);
        }
        if(params["method"] == "put"){
            return PUT(header);
        }
        NotImplemented();
    }
    void PUT(const CGI_Header* header) override{
        if(strcmp(req->get("X-Authorized"), "1") != 0) {
            Response(HttpResHeader::create(S403, sizeof(S403), req->request_id));
            Finish();
            return;
        }
        if(header->type == CGI_DATA){
            auto param = getparamsmap((char *)(header+1), ntohs(header->contentLength));
            params.insert(param.begin(), param.end());
        }
        if((flag & HTTP_REQ_COMPLETED) == 0){
            return;
        }
        if(params.count("site") == 0 || params.count("strategy") == 0) {
            BadRequest();
            return;
        }
        if(!c->AddStrategy(params["site"], params["strategy"], "").get_future().get()){
            BadRequest();
            return;
        }
        std::shared_ptr<HttpResHeader> res = HttpResHeader::create(S303, sizeof(S303), req->request_id);
        if(req->get("Referer") != nullptr){
            res->set("Location", req->get("Referer"));
        }else{
            res->set("Location", "/");
        }
        Response(res);
        Finish();
    }
    void DELETE(const CGI_Header* header)override{
        if(strcmp(req->get("X-Authorized"), "1") != 0) {
            Response(HttpResHeader::create(S403, sizeof(S403), req->request_id));
            Finish();
            return;
        }
        if(header->type == CGI_DATA){
            auto param = getparamsmap((char *)(header+1), ntohs(header->contentLength));
            params.insert(param.begin(), param.end());
        }
        if((flag & HTTP_REQ_COMPLETED) == 0){
            return;
        }
        if(params.count("site") == 0){
            BadRequest();
            return;
        }
        if(!c->DelStrategy(params["site"]).get_future().get()){
            BadRequest();
            return;
        }
        std::shared_ptr<HttpResHeader> res = HttpResHeader::create(S303, sizeof(S303), req->request_id);
        if(req->get("Referer") != nullptr){
            res->set("Location", req->get("Referer"));
        }else{
            res->set("Location", "/");
        }
        Response(res);
        Finish();
    }
public:
    handler(int sfd, int cfd, const char* name, const CGI_Header* header):CgiHandler(sfd, cfd, name, header){
        if(c == nullptr) {
            c = new SproxyClient(cfd);
        }
    }
};

SproxyClient* handler::c = nullptr;
CGIMAIN(handler);
